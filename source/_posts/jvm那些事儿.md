---
title: jvm那些事儿
toc: true
date: 2017-02-06 11:07:29
category: 
	- 技术贴
	- Java
	- JVM
tags: 
    - JVM
    - GC
---

# 概述
学Java的不懂点jvm那真是说不过去，对于研究jvm来说，不见得要把源码全部记下来，然后完全弄清楚来龙去脉（当然有精力且编程痴迷者忽略），对于jvm，大部分程序猿要做到的就是基本原理了熟于心，能进行基本的jvm调优且出了一些线上故障，要能通过观察当时内存，线程等程序的运行情况来揪出问题的根源。

## 内存模型
<!--more-->
![内存模型](/img/jvm.jpg)

- 堆
- 栈
- 方法区
- 本地方法栈
- 寄存器
- 堆外内存

### 寄存器(程序计数器)

作用：
    取下一条待执行的指令 
特点：
    线程独立，非共享，不存在OutOfMemoryError

### 栈(虚拟机栈)

作用：
    生命周期与每个方法（字节码）对应一个栈帧，存储局部变量/对象引用/操作数/方法出口，方法的调用－执行－返回对应虚拟机栈的入栈和出栈
说明：
    局部变量编译期空间分配完成 4类8种中除long double占用两个局部变量空间，其他占一个空间。
异常：
    （1）线程请求的栈深度大于虚拟机所允许的深度 StackOverflowError  
    （2）虚拟机扩展无法申请到足够的内存 OutOfMemoryError
    
### 本地方法栈

作用：
    Native方法服务栈
特点：
    与虚拟机栈相似，如：Sun HotSpot虚拟机直接把本地方法栈和虚拟机栈合二为一
    
### 堆

作用：
    存放对象实例/数组
时机：
    虚拟机启动时创建
特点：
    线程共享 垃圾收集器管理的主要区域
实现：
    逻辑连续，可扩展，通过-Xmx -Xms控制
异常：
    如果在堆上没有内存完成实例分配，且无法扩展 OutOfMemoryError    

### 方法区

作用：
    存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据
特点：
    线程共享 Sun HotSpot虚拟机称为“永久代”，可垃圾回收   JDK1.7之后字符串常量池不存放在永久代
异常：
     永久代上限 -XX:MaxPermSize 无法满足内存分配需求 OutOfMemoryError
     
#### 运行时常量池

作用：
    方法区一部分 存放编译期生成的各种字面量和符号引用
特点：
    String的intern()方法 在运行期间将新的常量放入常量池
异常：
    无法申请内存 OutOfMemoryError

### 堆外内存

说明：
    不属于java虚拟机内存，但由于jdk1.4后NIO的引入 可以使用Native函数直接分配堆外内存
好处：
    1.可以扩展至更大的内存空间。比如超过1TB甚至比主存还大的空间。
    2.理论上能减少GC暂停时间。
    3.可以在进程间共享，减少JVM间的对象复制，使得JVM的分割部署更容易实现。
    4.它的持久化存储可以支持快速重启，同时还能够在测试环境中重现生产数据。
异常：
    受系统物理内存影响，无法申请内存 OutOfMemoryError 

申请：
直接操作本地内存的方式有2种：使用未公开的Unsafe和NIO包下的ByteBuffer。

#### 堆外内存的优缺点
优点：
1.由于堆外内存不受jvm控制，减少了垃圾回收的工作，因为垃圾回收会暂停其他的工作
2.加快了复制的速度。这一点博主也是在整理博客时查阅资料才明白的。因为堆内在flush到远程时，会先复制到直接内存（非堆内存），然后在发送；而堆外内存相当于省略掉了这个工作。 
3.既然是不在虚拟机内部的内存，那么多进程下应用程序之间共享内存就有了可能，当然个人认为很少情况下会用，如果真有这种场景，为何不用（Redis,memcache)分布式缓存呢。
　　
缺点：
1.堆外内存难以控制，如果内存泄漏，那么很难排查，虽然说调用System.gc()可能也能回收，但是要知道垃圾回收是jvm的活，程序员就算调gc()方法也只是给jvm个建议，万一jvm一矫情，也不会执行回收操作。
2.堆外内存相对来说，不适合存储很复杂的对象。一般简单的对象或者扁平化的比较适合。
       
#### 何时释放，如何释放
- 何时释放
由于堆外内存并不直接控制于JVM，因此只能等到full GC的时候才能垃圾回收。
也就是说一般发生在年老代垃圾回收以及调用System.gc的时候。

- 如何释放
使用sun.misc.Cleaner或者PhantomReference实现堆外内存的自动释放，而不是覆盖finalize方法或者System.gc手动释放，因为这两种都对性能存在很大影响。

## GC
俗称垃圾回收，是java中一个相当重要的环节，不同于C/C++之处，Java的堆内存由jvm管理，所以回收也完全由jvm控制，不需要手动释放无用对象。

### YoungGC & Full GC
**回收类型**
YoungGC：回收的是新生代的可回收对象，一般指Eden区和两个Survivor区
Full GC:回收的是老年代的可回收对象，一般指Old区和Perm区。

**回收时机**
YoungGC：
- Eden区空间不足

Full GC：
- old区空间不足
- perm区空间不足
- 显示调用System.gc()，包括RMI等定时触发
- YoungGC时的悲观策略
- dump内存信息时（jmap）

详细介绍下悲观策略，其实就是它触发的机制是首先会计算从新生代ygc后要晋升到老年代的对象是否大于老年代剩余空间，如果老年代不足，则full gc一次。悲观则是说与其等到下次晋升发现空间不够，不如悲观的认为下次肯定触发full gc，那么先直接执行一次。

**回收步骤**
YoungGC
1.将eden区和from中的引用次数为0的对象清除
2.将eden区和from中的存活对象复制到to中
3.如果to放不下或者存活次数超过Tenuring Threshold,那么将会晋升到old中

Full GC
1.如果配置CollectGen0First,将会先执行YGC
2.清空heap中所有的引用为0的对象，以及卸载所有classLoader
3.单线程完成，全过程应用暂停

#### 方法区的回收
方法区也就是常说的永久代，主要回收两部分内容：废弃常量和无用的类
废弃常量的判定比较简单，就是看是否有任何地方引用了这个字面量
无用的类判定较为复杂，（1）该类所有实例都被回收 （2）加载该类的classLoader都被回收 （3）该类的.class没有被引用，不存在反射等访问

### 对象类型
**强引用：**
A a = new A();
只要引用在，不会进行回收

**软引用：**
SoftReference
在系统将要发生内存溢出异常之前，会进入回收范围中

**弱引用：**
WeakReference
引用只生存到下一次垃圾回收之前

**虚引用：**
PhantomReference
必定会回收，唯一的目的就是回收时收到一个系统通知

**强弱关系：**
强 》 软 》 弱 》 虚

### 回收算法
- 引用计数
- 标记-清除
- 复制
- 标记-整理
- 增量收集
- 分代收集


### 收集器
- 串行
- 并行
- 并发

**串行，并行和并发**  
串行：你吃饭吃到一半，电话来了，你一直到吃完了以后才去接
并行：你吃饭吃到一半，电话来了，你接电话的同时还继续吃饭
并发：你吃饭吃到一半，电话来了，你一边打电话一边吃饭，
并发的关键是你有处理多个任务的能力，不一定要同时。
并行的关键是你有同时处理多个任务的能力。
“并行”概念是“并发”概念的一个子集。也就是说，你可以编写一个拥有多个线程或者进程的并发程序，但如果没有多核处理器来执行这个程序，那么就不能以并行方式来运行代码

#### Serial收集器
单线程，串行收集，收集过程会Stop The World（服务暂停）；
新生代复制算法｜老年代标记-整理算法；
参数控制：-XX:+UseSerialGC

#### ParNew收集器
Serial收集器的多线程版本，新生代并行，老年代串行；
新生代复制算法｜老年代标记-整理算法；
参数控制：-XX:+UseParNewGC  -XX:ParallelGCThreads 限制线程数量

#### Parallel收集器
吞吐量优先

#### Serial Old 收集器
配合Serial，作为client端老年代收集器

#### Parallel Old 收集器
配合Parallel，作为server端老年代收集器

#### CMS收集器
jdk1.5
响应时间优先
配合ParNew，作为server端老年代收集器

初始标记
并发标记
重新标记
并发清除

#### G1收集器
jdk1.7
Region
Remembered Set
最短的时间回收最多的垃圾

初始标记
并发标记
重新标记
筛选回收

重新标记通过log合并将浮动垃圾再次回收

## 参数
### 基础参数
-Xms设置堆的最小空间大小。
-Xmx设置堆的最大空间大小。
-XX:NewSize设置新生代最小空间大小。
-XX:MaxNewSize设置新生代最大空间大小。
-XX:PermSize设置永久代最小空间大小。
-XX:MaxPermSize设置永久代最大空间大小。
-Xss设置每个线程的堆栈大小。
** 老年代是通过堆空间和新生代大小设置来控制的 老年代空间大小=堆空间大小-年轻代大空间大小 **


## 一张脑图（网上找的哈）
![jvm脑图](/img/jvm_02.jpg)