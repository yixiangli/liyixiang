---
title: 设计模式－创建型
toc: true
date: 2017-01-18 11:34:56
category: 
	- 技术贴
	- 设计模式
	- 创建型
tags: 
    - 创建型
    - 单例
---

# 创建型

设计模式来源于生活，在面向对象的世界里，世间万物皆对象，那么对象的创建方式就存在多种多样，自然也就形成了几种通用的设计模式。

## 种类
单例模式 	        SingleTon
原型模式		 Prototype
建造者模式		 Builder
简单工厂               SimpleFactory
工厂模式		 Factory
抽象工厂模式	 AbstractFactory

### 单例模式
适用场景：
    应用程序中的某个类只需要或者只能有一份实例在系统运行状态下。    
博主提示：
    一定要注意并发场景，最普通的（或者大学老师教的）那种单例还是不要写了，博主不废话，直接给出两种终极版，具体原因百度一下，这种博客太多了。

<!--more-->
#### 双重校验锁DCL
```
/**
 * @developer liyixiang
 * @date 2017年2月10日
 * @since JDK 1.8
 * @function	
 * 		双重加锁单例
 * 无法完全避免错误
 * 
 * 或者在静态实例加上volatile关键字 但是需要jdk1.5以上(因为volatile屏蔽指令重排序的语义在jdk1.5才被完全修复) 而且代码书写相对复杂
 * 
 * 首先要明白在JVM创建新的对象时，主要要经过三步。

              1.分配内存

              2.初始化构造器

              3.将对象指向分配的内存的地址

              这种顺序在上述双重加锁的方式是没有问题的，因为这种情况下JVM是完成了整个对象的构造才将内存的地址交给了对象。但是如果2和3步骤是相反的（2和3可能是相反的是因为JVM会针对字节码进行调优，而其中的一项调优便是调整指令的执行顺序），就会出现问题了。

              因为这时将会先将内存地址赋给对象，针对上述的双重加锁，就是说先将分配好的内存地址指给synchronizedSingleton，然后再进行初始化构造器，这时候后面的线程去请求getInstance方法时，会认为synchronizedSingleton对象已经实例化了，直接返回一个引用。如果在初始化构造器之前，这个线程使用了synchronizedSingleton，就会产生莫名的错误。
 */
public class DoubleSyncSingleTon {
	//一个静态实例
	private volatile static DoubleSyncSingleTon dss;
	//构造方法私有
	private DoubleSyncSingleTon(){}
	
	public static DoubleSyncSingleTon getInstance(){
		if(null == dss){
			synchronized (DoubleSyncSingleTon.class) {
				//再次判断dss是否为null
				/**
				 * 假设我们去掉同步块中的是否为null的判断，有这样一种情况，
				 * 假设A线程和B线程都在同步块外面判断了synchronizedSingleton为null，
				 * 结果A线程首先获得了线程锁，进入了同步块，然后A线程会创造一个实例，
				 * 此时synchronizedSingleton已经被赋予了实例，A线程退出同步块，
				 * 直接返回了第一个创造的实例，此时B线程获得线程锁，也进入同步块，
				 * 此时A线程其实已经创造好了实例，B线程正常情况应该直接返回的，
				 * 但是因为同步块里没有判断是否为null，直接就是一条创建实例的语句，
				 * 所以B线程也会创造一个实例返回，此时就造成创造了多个实例的情况。
				 */
				if(null == dss){
					dss = new DoubleSyncSingleTon();
				}
			}
		}
		return dss;
	}
}

```

#### 静态内部类

```
/**
 * @developer liyixiang
 * @date 2017年2月10日
 * @since JDK 1.8
 * @function
 * 		语言级别无法完全避免错误的发生
 * 		不考虑反射等强行突破，较为完美的单例模式解决方案，将该任务交给JVM
 */

/*
 *           1.Singleton最多只有一个实例，在不考虑反射强行突破访问限制的情况下。

             2.保证了并发访问的情况下，不会发生由于并发而产生多个实例。

             3.保证了并发访问的情况下，不会由于初始化动作未完全完成而造成使用了尚未正确初始化的实例。
 */
public class PerfectSingleTon {

	private PerfectSingleTon(){}
	
	//一个类的静态属性只会在第一次加载类时初始化，这是JVM帮我们保证的
	public static PerfectSingleTon getInstance(){
		return SingleTonInstance.instance;
	}
	
	//由于静态变量只初始化一次，所以singleton仍然是单例的。
	public static class SingleTonInstance {
		static PerfectSingleTon instance = new PerfectSingleTon();
	}
}
```

### 原型模式
适用场景：
    1.对象的创建比较复杂（如需要大量的setXXX），那么这个时候使用原型模式可以快速复制出大量的相同对象，而无需知道创建细节。
    2.在不知道该对象的创建方式情况下，使用该模式也能创建出相同的对象进行使用，或者获取到这个对象的运行状态。 
博主提示：
    3.由于clone方法是由虚拟机直接复制内存块执行，所以在速度上比使用new的方式创建对象要快，如果遇到需要大量相同对象的需求，那么new一个之后再各种clone效率更高（这点很好解释，上学的时候抄作业不用动脑子）
    注意概念：浅拷贝&深拷贝。记得博主大四参加百度校招还遇到过这个笔试题，当时并不知道这是个什么概念。
先来看浅拷贝

```

/**
 * @developer liyixiang
 * @date 2017年2月12日
 * @since JDK 1.8
 * @function
 * 		浅拷贝的例子
 */
public class ShallowPrototype implements Cloneable{

	private int x;
	private int y;
	private int z;
	private A a;
	
	public ShallowPrototype() {
		// TODO Auto-generated constructor stub
		this.x = 2;
        this.y = 3;
        this.z = 4;
        this.a = new A();
        this.a.setA(5);
	}
	
	public A getA(){
		return a;
	}
	
	public ShallowPrototype clone() {
		Object obj = null;
		try {
			obj = super.clone();
		} catch (CloneNotSupportedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return (ShallowPrototype) obj;
	}
	
	public String toString() {
        return "[" + x + "," + y + "," + z + "," + a.getA() + "]";
    }
	
	public static void main(String[] args) {
        ShallowPrototype prototype1 = new ShallowPrototype();
        System.out.println(prototype1);
        System.out.println(prototype1.getA());
        ShallowPrototype prototype2 = prototype1.clone();
        System.out.println(prototype2);
        System.out.println(prototype2.getA());
    }
}

结果
[2,3,4,5]
com.li.leader.dm.bean.A@677327b6
[2,3,4,5]
com.li.leader.dm.bean.A@677327b6
```

重点来了，博主在编写的时候漏掉了实现Cloneable接口，看了下Cloneable接口，并没有任何方法，由于真正的clone方法是在Object类中，以protected native声明，以为不需要实现，但是在运行的时候却报java.lang.CloneNotSupportedException错，查阅了资料发现类 Object 的 clone() 方法首先会检查 this.getClass() 是否实现了 Cloneable 接口，如果 this.getClass() 没有实现 Cloneable 接口， clone() 就会抛 CloneNotSupportedException 返回，这点十分重要。
本地方法Object.clone()的源代码

```
// Check if class of obj supports the Cloneable interface.
  // All arrays are considered to be cloneable (See JLS 20.1.5)
  if (!klass->is_cloneable()) {//这里检查了是否实现了Cloneable接口，如果没实现，会抛出异常CloneNotSupportException。
    ResourceMark rm(THREAD);
    THROW_MSG_0(vmSymbols::java_lang_CloneNotSupportedException(), klass->external_name());
  }
```

深拷贝如何实现？
一般有两种方法，第一种在重写的clone方法中显式声明要copy的对象



```
    protected DeepPrototype clone() {
        Object object = null;
        try {
            object = super.clone();
            ((DeepPrototype)object).field = this.field.clone();
        } catch (CloneNotSupportedException exception) {
            throw new RuntimeException(exception);
        }
        return (DeepPrototype) object;
    }
```

如果说被克隆类中有包含一个field，就需要一行代码，那么n个属性，就需要n行，扩展性也不好，因此一般会采用第二种，利用Java序列化技术实现

```
/**
	 * 
	 * @developer:liyixiang
	 * @function:
	 * 		借用序列化来做深克隆
	 * 		但是被克隆对象必须可序列化
	 * @param:
	 *		
	 * @return:
	 *
	 */
	public Object deepClone() throws IOException, ClassNotFoundException { 
		 //将对象写到流里 
		 ByteArrayOutputStream bo=new ByteArrayOutputStream(); 
		 ObjectOutputStream oo=new ObjectOutputStream(bo); 
		 oo.writeObject(this); 
		 //从流里读出来 
		 ByteArrayInputStream bi=new ByteArrayInputStream(bo.toByteArray()); 
		 ObjectInputStream oi=new ObjectInputStream(bi); 
		 return(oi.readObject()); 
	}
```

一个例子


```
/**
 * @developer liyixiang
 * @date 2017年2月13日
 * @since JDK 1.8
 * @function
 * 		一个教师类
 */
class Teacher implements Serializable{
	  /**
	   * @function:
	   *
	   */
	private static final long serialVersionUID = 1L;
	String name;
	int age;
	  
	  public Teacher(String name,int age){
		  this.name=name;
		  this.age=age;
	  }
}
	
public class Student implements Serializable{
	 /**
	 * @function:
	 *
	 */
	private static final long serialVersionUID = -1718229499251306525L;
	String name;//常量对象
	int age;
	Teacher t;//学生1和学生2的引用值都是一样的。

	public Student(String name,int age,Teacher t){
		  this.name=name;
		  this.age=age;
		  this.t=t;
	 }
	 
	 public static void main(String[] args) throws ClassNotFoundException, IOException{ 
		 Teacher t = new Teacher("tangliang",30);
		 Student s1 = new Student("zhangsan",18,t);
		 Student s2=(Student)s1.deepClone();
		 //修改s2 教师的属性
		 s2.t.name="tony";
		 s2.t.age=40;
		 //学生1的老师不改变
		 System.out.println("name="+s1.t.name+","+"age="+s1.t.age);
		 System.out.println("name="+s2.t.name+","+"age="+s2.t.age);
	 }
	 
	 public Object deepClone() throws IOException, ClassNotFoundException { 
		 //将对象写到流里 
		 ByteArrayOutputStream bo=new ByteArrayOutputStream(); 
		 ObjectOutputStream oo=new ObjectOutputStream(bo); 
		 oo.writeObject(this); 
		 //从流里读出来 
		 ByteArrayInputStream bi=new ByteArrayInputStream(bo.toByteArray()); 
		 ObjectInputStream oi=new ObjectInputStream(bi); 
		 return(oi.readObject()); 
	}
}
```

运行起来结果说明一切，值得一提的是

```
private static final long serialVersionUID = -1718229499251306525L;
```

简单解释下就是Java序列化时为了保证序列化前后对象的唯一性，声明这样一个标记来保证版本的兼容性，开发者可以显式的定义，也可以不定义，那么JVM会根据类属性，运行环境等等策略计算而生成一个64位的哈希字段，但是要注意，不同JVM可能有所不同。


### 建造者模式
想了解建造者模式，先看一个例子

```
public class Person {

	private int id;
	private String name;
	private int age;
	public int getId() {
		return id;
	}
	public void setId(int id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}

}
```

这是一个表示”人“的类，那么如何创建这个人呢，通常的做法是

```
Person p = new Person();
p.setId()
p.setName()
p.setAge()
```

现在，小用一下建造者模式，变形！！！

```
public class Person {

	private int id;
	private String name;
	private int age;

	public Person setId(int id) {
		this.id = id;
		return this;
	}

	public Person setName(String name) {
		this.name = name;
		return this;
	}

	public Person setAge(int age) {
		this.age = age;
		return this;
	}
	
}
```

如何使用？

```
new Person().setAge(18).setId(12345).setName("li");
```

这样的写法对于客户端（需要使用这个类来创建对象的人）来说代码简洁了不少，这也就是比较提倡的流式风格，但是有的人问了，难道建造者模式就这点作用？往下看

假设现在我们有一个新的类，这个类的属性有部分必填，有一些选填，那么如果用建造者模式，可以这么写

```
public class Person {

	private final int id;
	private final String name;
	private final int age;
	private final String level;

	private Person(PersonBuilder builder){
		this.id = builder.id;
		this.name = builder.name;
		this.age = builder.age;
		this.level = builder.level;
	}
	
	public int getId() {
		return id;
	}

	public String getName() {
		return name;
	}

	public int getAge() {
		return age;
	}

	public String getLevel() {
		return level;
	}

	//人类的建造者
	public static class PersonBuilder {
		private final String name;
		private final int id;
		private int age;
		private String level;
		
		public PersonBuilder(String name,int id){
			this.id = id;
			this.name = name;
		}
		
		public PersonBuilder age(int age){
			this.age = age;
			return this;
		}
		
		public PersonBuilder level(String level){
			this.level = level;
			return this;
		}
		
		//最后一哆嗦
		public Person build() {
                    return new Person(this);
               }
	}
}
```

这样我们的客户端使用起来只需要

```
               new Person.PersonBuilder("li", 12345);
		//如果有可选参数 那么
		new Person.PersonBuilder("li", 12345)
		.age(18)
		.level("一级")
		.build();
```

既简洁又易懂，而且很灵活，可以创建出很多不同的对象（如18岁，28岁，58岁的人，只需要传递不同的参数），关键是安全性也比普通类调用set方法好，建造者模式生成的是一个完整的对象，不存在个别属性别篡改的情况。另外，对于一些属性的参数性校验，可以统一放在build这一步去处理，例如

```
       public Person build() {
            if(age > 120){
                throw new Exception("");
            }
            return new Person(this);
        }
```
慢着，这种写法线程不安全

```
        public Person build() {
            Person p = new Person(this);
            if(age > 120){
                throw new Exception("");
            }
            return p;
        }
```


### 工厂，工厂
工厂，生产产品的地方，因此也是创建型设计模式中的一大类，而且派生出多个设计模式样例。

#### 简单工厂
看demo
```
/**
 * @developer liyixiang
 * @date 2017年2月15日
 * @since JDK 1.8
 * @function
 * 		简单工厂
 */
public class SimpleFactory {

	public Product createProduct(String name){
		 if("A".equals(name)){
			 return new ProductA("A");
		 }else {
			 return new ProductB("B");
		 }
	}

}

/**
 * 
 * @author liyixiang
 * 		产品接口
 */
interface Product{
	
}

//产品A
class ProductA implements Product {
	String name;
	public ProductA(String name) {
		// TODO Auto-generated constructor stub
		this.name = name;
	}
}

//产品B
class ProductB implements Product {
	String name;
	public ProductB(String name) {
		// TODO Auto-generated constructor stub
		this.name = name;
	}
}
```

总结一下就是一个工厂类，一个产品接口（其实也可以是一个抽象类，甚至一个普通的父类，但通常我们觉得接口是最稳定的，所以基本不需要考虑普通父类的情况），和一群实现了产品接口的具体产品，而这个工厂类，根据传入的参数去创造一个具体的实现类，并向上转型为接口作为结果返回。
缺点：
    扩展性很差，随着产品的升级进化，工厂类需要if else的改动，违反开闭原则，当然其实这个设计模式是大部分程序员最常用的。。。不承认也不行。

#### 工厂方法
既然简单工厂被吐槽了，那么就进化一下吧

```
/**
 * @developer liyixiang
 * @date 2017年2月15日
 * @since JDK 1.8
 * @function
 * 		工厂方法
 * 		比简单工厂就是将工厂部分给抽象化
 */
public interface Factory {
	Product getProduct();
}

class FactoryA implements Factory {

	@Override
	public Product getProduct() {
		// TODO Auto-generated method stub
		return new ProductA();
	}
	
}

class FactoryB implements Factory {

	@Override
	public Product getProduct() {
		// TODO Auto-generated method stub
		return new ProductB();
	}
	
}

//产品
interface Product {}

class ProductA implements Product {}

class ProductB implements Product {}
```

look,复杂的if else被Factory和他的孩子们替代了，如果现在再来一个产品C，那么就实现一个工厂C就可以了，遵循开闭原则，但是追求完美的小伙伴会觉得，工厂方法还是存在一些问题，因为只能生产Product这种类型的产品，那么我们再进化一波


#### 抽象工厂

```
/**
 * @developer liyixiang
 * @date 2017年2月15日
 * @since JDK 1.8
 * @function
 * 		抽象工厂
 * 		基于工厂方法，我们再变形，把产品也抽象一下
 */
//抽象产品1
interface Product{}
//抽象产品2
interface Product1{}

//产品群
class ProductA implements Product{}
class ProductB implements Product{}
class ProductA1 implements Product1{}
class ProductB1 implements Product1{}

public interface AbstractFactory {
	//创建Product类
	Product createProduct();
	//创建Product1类
	Product1 createProduct1();
}

//A工厂就负责生产A产品
class FactoryA implements AbstractFactory{

	@Override
	public Product createProduct() {
		// TODO Auto-generated method stub
		return new ProductA();
	}

	@Override
	public Product1 createProduct1() {
		// TODO Auto-generated method stub
		return new ProductA1();
	}
}


//B工厂就负责生产B产品
class FactoryB implements AbstractFactory{

	@Override
	public Product createProduct() {
		// TODO Auto-generated method stub
		return new ProductB();
	}

	@Override
	public Product1 createProduct1() {
		// TODO Auto-generated method stub
		return new ProductB1();
	}
}

```
简直神奇，是不是
最后总结一波，工厂方法是对简单工厂中工厂类进行抽象，而抽象工厂是将产品也进行了抽象，在实际开发工作中，要根据实际情况选择，也不要因为抽象工厂可能更抽象化而增加代码复杂度。