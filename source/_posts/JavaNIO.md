---
title: JavaNIO
toc: true
date: 2017-02-13 16:50:02
category: 
	- 技术贴
	- Java
	- 基础
tags: 
    - nio
---

# NIO

## 概念对比
**BIO/NIO/AIO：**
BIO是同步阻塞的
NIO是同步非阻塞的
AIO是异步非阻塞的

BIO会引入多个线程，每个连接都会有一个单独的线程
NIO只需要少量线程，或者单线程，多个连接公用线程

<!--more-->
连接层面上的区别如图：
![BIO与NIO区别](/img/bio与nio.jpg)

如图所示，nio的处理流程是当一个连接创建后，不像bio那样需要对应一个线程，而是将这个连接注册到多路复用器Selector上面，所以是多个连接公用线程，而多路复用器Selector进行轮询的时候，发现连接上有请求的话，才开启一个线程进行处理，也就是一个请求一个线程模式，针对于这种模式，在博主自己开发的breeze框架中深刻体会到其中的问题，那就是当并发请求量大时，如果处理请求的后端线程在等待一系列资源（如博主遇到的数据库瓶颈），那么还是会和BIO一样的问题，导致线程资源过多或者不够用（线程池）

**总结一下：**
面向流 vs. 面向缓冲
阻塞 vs. 非阻塞
选择器（Selector）
零拷贝
	这点解释下，就是可直接把FileChannel中的数据拷贝到另外一个Channel，或者直接把另外一个Channel中的数据拷贝到FileChannel，并不需要将源数据从内核态拷贝到用户态，再从用户态拷贝到目标通道的内核态，同时也避免了两次用户态和内核态间的上下文切换


AIO:
首先从NIO模型可以看出，NIO的整个流程并不是异步的，客户端在请求发出后还是会等待响应，因此如果要实现异步非阻塞（AIO），在NIO的基础上加一个队列或者资源池，负责连接的线程将请求接受，并将请求数据传送到后端队列或者资源池中，而后端线程组只负责从队列或者资源池中取数据处理，处理完回调（连接与请求一一匹配，也就是从哪来的回哪去），这就是真正的异步非阻塞了。

BIO是一个连接一个线程。
NIO是一个请求一个线程。
AIO是一个有效请求一个线程。

**同步&异步**
消息通信机制

同步：发出一个*调用*时，在没有得到结果之前，该*调用*就不返回，一旦调用返回，会得到返回值

异步：*调用*在发出之后，这个调用就直接返回了，所以没有返回结果，而后*被调用者*通过状态、通知来通知调用者，或通过回调函数处理这个调用。

**阻塞&非阻塞**
程序在等待调用结果（消息，返回值）时的状态

阻塞：指调用结果返回之前，当前线程会被*挂起*。调用线程只有在得到结果之后才会返回。

非阻塞：指在不能立刻得到结果之前，该调用不会阻塞当前线程。

**黄焖鸡**
记得之前做技术分享的时候举的例子：

同步阻塞：
<br/>&emsp;&emsp;打电话给黄焖鸡老板，“给我来一份黄焖鸡”，老板答：“稍等一下，我看下还有没有黄焖鸡”，然后你就一直举着电话等着老板告诉你结果

同步非阻塞：
<br/>&emsp;&emsp;打电话给黄焖鸡老板，“给我来一份黄焖鸡“，老板答：“稍等一下，我看下还有没有黄焖鸡”，然后你一边拿着电话等老板回信，一边用另一只手敲了两行代码（真敬业）。

异步阻塞：
<br/>&emsp;&emsp;打电话给黄焖鸡老板，“给我来一份黄焖鸡”，老板答：“好的，我先看看有没有黄焖鸡，有了回你电话”，然后老板挂了电话，但是你就一直发呆，等老板的电话告诉你结果

异步非阻塞：
<br/>&emsp;&emsp;打电话给黄焖鸡老板，“给我来一份黄焖鸡”，老板答：“好的，我先看看有没有黄焖鸡，有了回你电话”，然后老板挂了电话，你就继续敲你的代码。

看完了这个例子，相信已经很清晰了，那么再分析下这两者的区别
**同步&阻塞**
等待函数返回时线程是否处理其他事（是等着啥也不干还是在一边等一边做别的事）

**异步&非阻塞**
调用函数完毕后是否一直等待回调，如果一直等回调则是异步阻塞。


### 一个重要概念 
**poll & select**
对于监听I/0事件的代理，可以同时观察许多流的I/O事件，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中醒来，会轮询一遍所有的流，由于并不知道具体有多少流发生I/O事件，因此要遍历整个fd（文件描述符）集合，因此处理的复杂度为O(n)

**epoll**
event poll,基于事件驱动，也就是说哪个流上发生了I/O事件，epoll就会主动触发并通知用户处理，也就是说它只需要关注活跃的fd，减少了遍历，因此复杂度为O(1)。那么如何实现的呢？其实这就是Linux内核帮我们完成的了。

对于nio来说，其实nio中的Selector的取名总让我以为是类似于select/poll的模型，但是你会发现，当有数据被准备好时，调用完select()后，会返回一个SelectionKey，SelectionKey表示在某个selector上的某个Channel的数据已经被准备好了，进入select()源码可以看到，在Linux下，内核版本大于2.6时使用epoll，小于2.6时使用poll



## Buffer剖析
Buffer是nio中一个重要的概念，其本质上就是一块基于内存的缓冲区，可读也可写，在io中其实有缓冲的概念，flush方法就是将缓冲中余下数据写出，而在java1.4出现了nio后，Buffer作为通道(Channel)与通道之间连接的缓冲区，起到了重要作用。

### 两模式与三要素

两模式

- 写模式
- 读模式

三要素

- capacity
- position
- limit

<!--more-->
capacity
首先capacity很好理解，不论是读模式还是写模式，capacity就是Buffer区的总大小，是一个固定的值，超过这个大小，写入将无法进行。

position,位置标志
在写模式下，写数据到Buffer中时，position会向前移动到下一个可插入数据的Buffer单元，此时position表示当前可写入的位置，position最大可为capacity-1
在读模式下，position会被重置为0. 当从Buffer的position处读取数据时，position向前移动到下一个可读的位置。
看到这里，大家就会有个疑问，当写模式切换到读模式下，position被重置为0了，那么这个时候如果读模式又被切换回来了，Buffer怎么知道写到哪了呢。别着急，还有limit.

limit 
在写模式下，Buffer的limit表示你最多能往Buffer里写多少数据。所以写模式下，limit等于Buffer的capacity。
在读模式下，limit表示你最多能读到多少数据。因此，当切换Buffer到读模式时，limit会被设置成写模式下的position值。


### 常用api
#### flip()
说完了三要素，大家又觉得疑问了，怎么从读模式切换到写模式（或者说反过来），这就要说到flip方法了。

#### rewind()
将position设回0，可以重读Buffer中的所有数据。

#### clear()与compact()
一般写入前调用
clear会将position将被设回0，limit被设置成 capacity的值，可以理解为Buffer被清空，但是实际上数据还在，不过新写入的数据会被覆盖，而且不用担心，切换到读模式后,新的position等于新的limit，不会读出原来的数据。
compact()方法将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个未读元素正后面。limit属性依然像clear()方法一样，设置成capacity。现在Buffer准备好写数据了，但是不会覆盖未读的数据。

#### mark()与reset()
顾名思义，mark一下，将当前position记住，reset就是复原position。

#### equals()与compareTo()
equals() 比较两个Buffer是否相同

- Buffer类型相同
- 剩余数据个数相等
- 剩余数据内容也想等

compareTo() 比较两个Buffer的大小

- 剩余元素中，比较数据内容大小
- 数据内容相等情况下，比较数据个数
