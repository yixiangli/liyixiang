---
title: 协议入门
toc: true
date: 2017-01-10 10:30:59
category: 
	- 技术贴
	- 网络
	- 协议
tags: 
    - 协议 http  smtp tcp
---


# 一张图
![协议大全](/img/protocol.jpg)


## 应用层

### HTTP

缺省端口：80
使用TCP协议

#### 状态码
1××	以1字字开头的三位数表示服务器已经接受到请求，并且正在处理中
2×× 以2字开头的三位数 表示请求成功
3×× 以3字开头的三位数表示请求被重定向(比如跳出服务器去github上请求jquery)
4xx	以4字开头的三位书表示客户请求错误(比如客户请求的资源不存在)
5xx	以5字开头的三位数表示服务器内部出错

<!--more-->
##### 部分状态码详解

##### 302
有新的请求地址，进行重定向

##### 401
未授权：登录失败 一般是权限问题，包括登录以及证书验证等

##### 403
禁止访问，一般都是服务器管理员刻意设置该状态，表示拒绝处理客户端的请求

##### 404
最常见了，找不到该页面 

##### 405
这个状态码还比较常见，get请求去访问一个post接口。因此这个状态码就是检测请求方法是否符合服务端设置

##### 413
这个状态码一般是请求实体过大，我遇到的时候是文件上传时大小被服务端限制，比如要上传一个500M的文件，而服务端如果在nginx没有配置相应的限制的话默认只有1M,就会被返回413.

nginx配置如下
```
location /v1 {
            proxy_pass   http://lepush_server;
            client_max_body_size   500m;  
}
```

一般web服务会使用spring做上传功能
```
<bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
    	<!-- 编码方式 -->
        <property name="defaultEncoding" value="UTF-8" />
        <!-- 最大上传文件大小500M = 524288000 byte = 500*1024*1024 byte 文件大小限制将在控制器中 -->
        <property name="maxUploadSize" value="524288000" />
        <!-- 最大占用内存大小 2M = 2097152 byte = 2*1024*1024 byte -->
        <property name="maxInMemorySize" value="2097152" />
</bean>
```
具体实现还是请自行学习上传，本文重点状态码。

##### 499
499这个状态码可以理解为是nginx中定义的状态码，因此在nginx日志中尤其是为用户移动设备提供服务的节点常会遇到，博主一开始遇到这个状态码后查了一些资料发现是客户端主动断开连接，不过客户端主动断开原因也有很多，经过调查发现可能存在如下几种情况
（1）客户端发出请求后，服务端还没有处理完（服务端正常处理），网络断了，一般这种情况时间比较短
（2）客户端发出请求后，服务端还没有处理完（服务端处理时间过长），过了客户端设置的超时时间，客户端主动断开，一般这种情况时间有一定规律，可以从客户端日志看

那么解决这个问题的办法也众说风云，不过经过博主的实践，在nginx上配置
proxy_ignore_client_abort on 表示#不允许代理端主动关闭连接 

##### 500
服务器内部错误，好好检查你的代码逻辑或者是否有没catch的异常

##### 501
未实现，是指发起的请求，Web服务器不理解或者不支持。
如，我给一个只支持HTTP GET请求的Web服务发送Post请求，就会返回501

##### 502
服务不可用，一般公司运维团队都会自己做slb(接入负载均衡)，那么slb的策略是后端机器如果一段时间大量504，就会认为后端服务出了问题，slb会进行剔除操作，将有问题的机器剔除，此时返回状态码为502。
当然还有一种情况那就是后端就是挂了或者服务正在部署升级，web服务器直接返回502。

##### 503
过载保护，是一种保护服务端的手段，不过一般都是暂时的，响应头中可以包含一个Retry-After头用以标明这个延迟时间，如果没有给出这个Retry-After信息，那么客户端应当以处理500响应的方式处理它

##### 504
网关超时，一般都是后端响应慢

#### 长连接和短连接

##### 面向连接
Http的长连接与短连接本质上就是tcp的长连接与短连接，tcp作为http传输层使用的协议，解决如何在IP层之上可靠的传递数据包，而在网络层使用ip协议解决网络路由和寻址问题，TCP有可靠，面向连接的特点，因此http是面向连接的协议。

##### 无状态
无状态很好解释，这次你上网打开一个网页和下一次再打开这个网页之间没有任何联系，服务没有任何关联性与记忆能力，因此http是一种无状态的协议

#### 缺陷
1.半双工协议，无法同一时刻在客户端与服务端做数据传递
2.文本方式传输，包括消息头，消息体等等，冗长而繁琐
3.长时间轮询，持续占用连接，消耗资源

### HTTPS
以安全为目标的HTTP通道，可以理解为HTTP的安全版，HTTPS与HTTP的主要区别就是在会话层加入了SSL,由SSL对详细内容进行加密，保证了安全性。

缺省端口：443
使用TCP协议


### DNS(Domain Name System)
域名系统，作用是将域名和ip对应起来，方便互联网用户使用（贼长的ip想记也记不住几个啊） 

缺省端口：53
使用UDP协议

Linux : DNS服务器的IP地址保存在/etc/resolv.conf文件

常见小白问题：
某人：我的电脑为什么可以登录qq，但是上不去网啊？
博主：DNS的问题呀

解决方法
1.有360的同学诊断下网络就会提示DNS出了问题
2.自己拿手机连3G 4G（电脑上不去网哟，写博客不能自相矛盾）百度下所在地DNS服务器地址，然后打开网络和共享中心，找到本地连接或者无线连接，属性，选择Internet ipv4，修改首选服务器DNS以及备用服务器DNS（具体的ip一百度就有，美国的是8.8.8.8）

### AMQP
AMQP(Advanced Message Queuing Protocol)是一个提供统一消息服务的应用层标准协议，基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同开发语言等条件的限制!

### AJP
AJP（Apache JServ Protocol）是定向包协议
tomcat的8009端口主要提供的就是ajp协议，该协议主要用于tomcat等servlet容器与其他HTTP服务器集成时使用

![AJP协议](/img/ajp.png)

如图所示
Web客户1直接访问Tomcat服务器上的JSP组件，他访问的 URL为http://localhost:8080 /index.jsp。Web客户2通过HTTP服务器访问Tomcat服务器上的JSP组件。假定HTTP服务器使用的HTTP端口为默认的80端口， 那么Web客户2访问的URL为http://localhost:80/index.jsp 或者 http://localhost/index.jsp。
在实际生产环境下，我们常见的基础架构如Nginx+tomcat就可以使用这种协议来提升性能。

## 表示层


## 会话层

### ldap
轻量级目录访问协议
缺省端口：389 
一般在sso中使用

### ssl
安全套接字层协议
缺省端口：443
使用TCP协议
apple提供的官网推送服务APNs 
服务端与APNs交互使用的就是ssl协议 

### tls
安全传输层协议
使用TCP协议
TLS是SSL v3.0的升级版，目前市面上所有的https都是用的是TLS，而不是SSL。


## 传输层


## 网络层
### arp
地址解析协议
负责将某个IP地址解析成对应的MAC地址

#### arp攻击
arp攻击就是通过伪造ip地址和mac地址实现arp欺骗，能够在网络中产生大量的ARP通信量使网络阻塞
不过由于是ip-mac转换，在网络层进行，因此只能在内网（局域网）攻击，无法对外网进行攻击。
预防arp攻击的解决方法是在网络中的交换机上配置802.1x协议，IEEE 802.1x是基于端口的访问控制协议，它对连接到交换机的用户进行认证和授权

### IP


## 数据链路层




