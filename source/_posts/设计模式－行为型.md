---
title: 设计模式－行为型
toc: true
date: 2017-02-16 14:45:02
category: 
	- 技术贴
	- 设计模式
	- 行为型
tags: 
    - 行为型
    - 策略
    - 观察
---


# 行为型
说到行为型，个人理解其实就是在软件设计过程中针对动态过程的一种设计方法，不同于结构型，行为型更侧重于局部特征。

## 种类
迭代器模式	        Iterator
中介者模式	        Mediator
备忘录模式	        Memento
观察者模式	        Observer
状态模式	        	State
策略模式	        	Strategy
模板方法模式	 		Template
访问者模式	        Visitor
职责连模式	        Chain
命令模式             Command

<!--more-->
### 迭代器模式
不暴露对象的内部表示，将遍历分离

### 中介者模式
复杂对象多对多关系的解耦，抽象出一个中介管理中心，统一管理复杂对象之间的交互

### 备忘录模式
需要在对象的外部保存该对象的内部状态（抽取记忆）

### 观察者模式
发布与订阅，消费与生产，程序解耦神器

### 状态模式
由多态引出的一种模式，支持状态相互切换

### 策略模式
一个问题的多种解决方式，支持动态替换

### 访问者模式
数据结构与访问行为分离，访问行为支持动态扩展（老板和注会都要查账）

### 职责链模式

#### 实战-解决MQ消息根据不同类型进行接收处理的case

这是一段及其复杂的if/else判断逻辑
```
if (mqMessage.getMessageActionCode() == MMSMessageActionCode.ALBUM_INSERT.getDbValue()) {// 专辑添加
			getBean("albumAddListener").handleMessage(mqMessage);
} else if (mqMessage.getMessageActionCode() == MMSMessageActionCode.ALBUM_UPDATE.getDbValue()) {// 专辑修改
			getBean("albumUpdateListener").handleMessage(mqMessage);
}else if (mqMessage.getMessageActionCode() == MMSMessageActionCode.ALBUM_DELETE.getDbValue()) {// 专辑删除
			getBean("albumDeleteListener").handleMessage(mqMessage);
} else if (mqMessage.getMessageActionCode() == MMSMessageActionCode.VIDEO_INSERT.getDbValue()) {// 视频添加
			getBean("videoAddListener").handleMessage(mqMessage);
} else if (mqMessage.getMessageActionCode() == MMSMessageActionCode.VIDEO_UPDATE.getDbValue()) {// 视频修改
			getBean("videoUpdateListener").handleMessage(mqMessage);
} else if (mqMessage.getMessageActionCode() == MMSMessageActionCode.VIDEO_DELETE.getDbValue()) {// 视频删除
			getBean("videoDeleteListener").handleMessage(mqMessage);
}else if (mqMessage.getMessageActionCode() == MMSMessageActionCode.DICTIONARY_DELETE.getDbValue()) {// 字典删除
			getBean("dictionaryDeleteListener").handleMessage(mqMessage);
}  else if (mqMessage.getMessageActionCode() == MMSMessageActionCode.DICTIONARY_INSERT.getDbValue()) {// 字典添加
			getBean("dictionaryInsertListener").handleMessage(mqMessage);
} else if (mqMessage.getMessageActionCode() == MMSMessageActionCode.DICTIONARY_UPDATE.getDbValue()) {// 字典修改
			getBean("dictionaryUpdateListener").handleMessage(mqMessage);
} else if (mqMessage.getMessageActionCode() == MMSMessageActionCode.STAR_INSERT.getDbValue()) {// 明星添加
			getBean("starInsertListener").handleMessage(mqMessage);
} else if (mqMessage.getMessageActionCode() == MMSMessageActionCode.STAR_UPDATE.getDbValue()) {// 明星修改
			getBean("starUpdateListener").handleMessage(mqMessage);
} else if (mqMessage.getMessageActionCode() == MMSMessageActionCode.TV_INSERT.getDbValue()) {// 电视台添加
			getBean("tvInsertListener").handleMessage(mqMessage);
} else if (mqMessage.getMessageActionCode() == MMSMessageActionCode.TV_UPDATE.getDbValue()) {// 电视台修改
			getBean("tvUpdateListener").handleMessage(mqMessage);
}
```

缺点：
（1）扩展性不好
（2）判断分支过于庞大
（3）且请求者与处理者紧耦合。
如何用职责链优化？抽象出一个AbstractListenerChain责任链抽象类

```
public abstract class AbstractListenerChain implements IMQHandler{
		protected AbstractListenerChain nextListenerChain;          //下一个责任链节点的引用
	protected byte actionCode;				    //请求判断规则

	public void setActionCode(byte actionCode) {
		this.actionCode = actionCode;
	}

	public byte getActionCode() {
		return actionCode;
	}

	public void setNextListenerChain(AbstractListenerChain nextListenerChain) {
		this.nextListenerChain = nextListenerChain;
	}

	/**
	 * 
	 * @throws Exception 
	 * @liyixiang
	 * @TODO:
	 * 		接收MQ中的消息，根据ActionCode来判断
	 * 是何种操作类型。
	 */
	public void receiveMessageRequest(byte actionCode,IMessage mqMessage) throws Exception{
		
		//判断actionCode是否符合
		if(getActionCode() == actionCode){
			handleMessage(mqMessage);
		}
		
		//如果不符合，继续向下传递请求
		if(nextListenerChain !=null){
			nextListenerChain.receiveMessageRequest(actionCode, mqMessage);
		}
				
	}

	//具体处理消息的业务方法
	public abstract void handleMessage(IMessage mqMessage) throws Exception;
```

此时之前的if/else

```
AbstractListenerChain abstractListenerChain = getFirstListenerNode();//返回当前链节点
abstractListenerChain.receiveMessageRequest(mqMessage.getMessageActionCode(), mqMessage);
```
但是需要一个方法构建这个职责链

```
构建责任链的方法

private AbstractListenerChain getFirstListenerNode(){

		//初始化所有链节点
		AbstractListenerChain albumAddListener = (AbstractListenerChain) getBean("albumAddListener");
		AbstractListenerChain albumUpdateListener = (AbstractListenerChain)getBean("albumUpdateListener");
		AbstractListenerChain albumDeleteListener = (AbstractListenerChain)getBean("albumDeleteListener");
		AbstractListenerChain videoAddListener = (AbstractListenerChain)getBean("videoAddListener");
		AbstractListenerChain videoUpdateListener =(AbstractListenerChain)getBean("videoUpdateListener");
		AbstractListenerChain videoDeleteListener =(AbstractListenerChain)getBean("videoDeleteListener");	
		AbstractListenerChain dictionaryInsertListener = (AbstractListenerChain)getBean("dictionaryInsertListener");
		AbstractListenerChain dictionaryUpdateListener = (AbstractListenerChain)getBean("dictionaryUpdateListener");
		AbstractListenerChain dictionaryDeleteListener = (AbstractListenerChain)getBean("dictionaryDeleteListener");
		AbstractListenerChain starInsertListener = (AbstractListenerChain)getBean("starInsertListener");		
		AbstractListenerChain starUpdateListener = (AbstractListenerChain)getBean("starUpdateListener");
		AbstractListenerChain tvInsertListener = (AbstractListenerChain)getBean("tvInsertListener");
		AbstractListenerChain tvUpdateListener = (AbstractListenerChain)getBean("tvUpdateListener");
	
		//设置每个节点ActionCode
		albumAddListener.setActionCode(MMSMessageActionCode.ALBUM_INSERT.getDbValue());
		albumUpdateListener.setActionCode(MMSMessageActionCode.ALBUM_UPDATE.getDbValue());
		albumDeleteListener.setActionCode(MMSMessageActionCode.ALBUM_DELETE.getDbValue());
		videoAddListener.setActionCode(MMSMessageActionCode.VIDEO_INSERT.getDbValue());
		videoUpdateListener.setActionCode(MMSMessageActionCode.VIDEO_UPDATE.getDbValue());
		videoDeleteListener.setActionCode(MMSMessageActionCode.VIDEO_DELETE.getDbValue());
		dictionaryInsertListener.setActionCode(MMSMessageActionCode.DICTIONARY_INSERT.getDbValue());
		dictionaryUpdateListener.setActionCode(MMSMessageActionCode.DICTIONARY_UPDATE.getDbValue());
		dictionaryDeleteListener.setActionCode(MMSMessageActionCode.DICTIONARY_DELETE.getDbValue());
		starInsertListener.setActionCode(MMSMessageActionCode.STAR_INSERT.getDbValue());
		starUpdateListener.setActionCode(MMSMessageActionCode.STAR_UPDATE.getDbValue());
		tvInsertListener.setActionCode(MMSMessageActionCode.TV_INSERT.getDbValue());
		tvUpdateListener.setActionCode(MMSMessageActionCode.TV_UPDATE.getDbValue());
	
		//形成责任链
		albumAddListener.setNextListenerChain(albumUpdateListener);
		albumUpdateListener.setNextListenerChain(albumDeleteListener);
		albumDeleteListener.setNextListenerChain(videoAddListener);
		videoAddListener.setNextListenerChain(videoUpdateListener);
		videoUpdateListener.setNextListenerChain(dictionaryInsertListener);
		dictionaryInsertListener.setNextListenerChain(dictionaryUpdateListener);
		dictionaryUpdateListener.setNextListenerChain(dictionaryDeleteListener);
		dictionaryDeleteListener.setNextListenerChain(starInsertListener);
		starInsertListener.setNextListenerChain(starUpdateListener);
		starUpdateListener.setNextListenerChain(tvInsertListener);
		tvInsertListener.setNextListenerChain(tvUpdateListener);
		
		//返回首节点
		return albumAddListener;
	}
```
改进后：
（1）请求者与处理者解耦，请求者不再关心最终是谁处理了它发送过去的消息
（2）今后扩展，只需继承责任链抽象类，无需多重判断
缺点：
（1）初始化责任链代码过大，且处理者之间耦合。
那么怎么继续优化？


```
public abstract class AbstractListenerChain implements IMQHandler{

	protected AbstractListenerChain nextListenerChain;          //下一个责任链节点的引用

	public void setNextListenerChain(AbstractListenerChain nextListenerChain) {
		this.nextListenerChain = nextListenerChain;
	}

	/**
	 * 
	 * @throws Exception 
	 * @liyixiang
	 * @TODO:
	 * 		接收MQ中的消息，根据ActionCode来判断
	 * 是何种操作类型。
	 */
	public void receiveMessageRequest(IMessage mqMessage) throws Exception{
		
		//判断actionCode是否符合
		if(compareActionCode(mqMessage)){
			handleMessage(mqMessage);
		}
		
		//如果不符合，继续向下传递请求
		if(nextListenerChain !=null){
			nextListenerChain.receiveMessageRequest(mqMessage);
		}
				
	}
	//具体处理消息的业务方法
	public abstract void handleMessage(IMessage mqMessage) throws Exception;
	
	//请求比较判断方法
	protected abstract boolean compareActionCode(IMessage mqMessage);
	
	//actionCode比较规则
	protected boolean compareRules(byte actionCode,IMessage mqMessage){
		return actionCode == mqMessage.getMessageActionCode();
	}
}
```

那么现在每个处理者可以通过继承抽象类实现解耦

```
@Override
	protected boolean compareActionCode(IMessage mqMessage) {
		// TODO Auto-generated method stub
		return compareRules(MMSMessageActionCode.ALBUM_INSERT.getDbValue(),mqMessage);
	}
```

对于actionCode的初始化放在了各个处理者类中，责任链类只需调用compareActionCode方法，即判断决定是否处理消息。具体的compareRules比较规则相同，就可以抽象在抽象类中统一实现，各个处理者只需调用即可完成判断
改进后：
（1）各个处理者解耦，各自处理各自请求，互不相干。
（2）今后增加责任链节点也无需再修改proxy类的代码（开闭原则）


### 命令模式
将行为请求者与行为执行者解耦，命令管理，统一指挥执行者（没有产品经理的程序猿们是多么悲惨）


