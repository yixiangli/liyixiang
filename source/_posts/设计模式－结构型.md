---
title: 设计模式－结构型
toc: true
date: 2017-01-18 11:35:47
category: 
	- 技术贴
	- 设计模式
	- 结构型
tags: 
    - 结构型
    - 适配器
---

# 结构型
软件工程来源于建筑，设计模式来源于生活，设计模式本身是某种特定场景下的一种解决方案，而结构型侧重于处理一些代码层次结构问题的解决方法。

## 种类
代理模式 			Proxy
适配器模式		       Adapter
桥接模式			Bridge
装饰器模式		       Decorator
外观模式			Facade
组合模式			Composite
享元模式			Flyweight

<!--more-->
### 代理模式
概述：
    秘书，帮你干杂活   
    中介，帮你找房源
作用：
    代替你做事

#### 静态代理
不再详述，一个类就需要一个代理类

#### 动态代理
主要有两种实现，JDK动态代理与Cglib，大家都在说，JDK动态代理的原理是针对接口，而Cglib是针对类，但是并不代表使用JDK动态代理的被代理类一定要implements某个接口，例子后面给出。

##### JDK动态代理

这有一个接口

```
/**
 * @developer liyixiang
 * @date 2017年2月21日
 * @since JDK 1.8
 * @function
 */
public interface Conn {

	void close();
}
```

再来一个类

```
/**
 * @developer liyixiang
 * @date 2017年2月21日
 * @since JDK 1.8
 * @function
 */
public class ConnBean{

	public void close(){
		System.out.println("sssss");
	}
}
```

看清楚了 并没有实现Conn接口，看代理类

```
/**
 * @developer liyixiang
 * @date 2017年2月21日
 * @since JDK 1.8
 * @function
 */
public class DynamicProxy implements InvocationHandler{

	private Object target;
	
	public DynamicProxy(Object target) {
		// TODO Auto-generated constructor stub
		this.target = target;
	}
	
	@Override
	public Object invoke(Object proxy, Method method, Object[] args)
			throws Throwable {
		// TODO Auto-generated method stub
		/**
		if(Conn.class.isAssignableFrom(proxy.getClass()) && method.getName().equals("close")){
			System.out.println("before");
			method.invoke(target, args);
			System.out.println("after");
		}
		**/
		System.out.println("before");
        Method sourceMethod = target.getClass().getDeclaredMethod(method.getName(), method.getParameterTypes());
        sourceMethod.setAccessible(true);
        Object result = sourceMethod.invoke(target, args);
        System.out.println("after");
        return result;
	}

}
```

重点就是这两句

```
 Method sourceMethod = target.getClass().getDeclaredMethod(method.getName(), method.getParameterTypes());
        sourceMethod.setAccessible(true);
```

当然，博主一开始也没明白为啥这么做就可以，那么就深入研究下吧。


##### Cglib
cglib是针对类来实现代理的，其实现原理：CGLIB的底层采用ASM字节码生成框架，使用字节码技术生成代理，比使用反射生成代理的效果要高，是对指定的目标类生成一个子类，并覆盖其中方法实现增强。但是也有一点点不足，因为采用的是继承，所以不能对final修饰的类进行代理。

使用CGLIB,需要实现 CGLib 给我们提供的 MethodInterceptor 实现类，并填充 intercept() 方法

### 适配器模式
类适配器，对象适配器，接口适配器（一种考虑兼容的设计模式）

### 桥接模式
先有两端，再架设这个桥，使两端连通

### 装饰模式
包装对象，增加对象的额外功能（IO包装类）

### 外观模式
拿程序狗最熟悉的Computer为,将cpu,内存条,硬盘的细节全部封装起来，组成了所谓的Computer，对外是看不到cpu,内存等组件的，所以外观模式（有的也叫门面模式）侧重点是将内部细节组装，对外屏蔽，只能看到外部对象。

一个demo
```
public class ComputerFacade {

    private CPU cpu;
    private Memory memory;
    private Disk disk;
 
    public ComputerFacade() {
        cpu = new CPU();
        memory = new Memory();
        disk = new Disk();
    }
 
    public void startup() {
        System.out.println("start the computer!");
        cpu.startup();
        memory.startup();
        disk.startup();
        System.out.println("start computer finished!");
    }
 
    public void shutdown() {
        System.out.println("begin to close the computer!");
        cpu.shutdown();
        memory.shutdown();
        disk.shutdown();
        System.out.println("computer closed!");
    }
}
```

实战，参见breeze源码（https://github.com/yixiangli/breeze）
（只有demo的设计模式案例都是白扯）

```
类名：
com.le.ag.breeze.server.facade.BreezeServerFacade

使用breeze框架都需要继承BreezeServerFacade类，BreezeServerFacade
就是breeze框架的一个整体门面，负责对外提供启动方法，而具体的启动流程（如Server Service Component启动等）都屏蔽在内，不对外暴露

public class BootStrapEntrance extends BreezeServerFacade{

	private static final int DEFAULT_PORT = 9040;

	public static void main(String[] args) {
		int port = DEFAULT_PORT;
		if (args.length > 0) {
                   port = StringUtils.toInt(args[0], DEFAULT_PORT);
         }
		BootStrapEntrance bootstrap = new BootStrapEntrance();
		ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext("classpath*:spring/applicationContext.xml");
		SpringUtils.setApplicationContext(ctx);
		//之与外观对象交互
		bootstrap.startup(port);
	}
}
```

### 组合模式
树结构，根／枝干／叶子
文件结构，文件夹／文件

组合模式可以理解为部分和整体的关系，那么想对于代码层次结构来说就是将部分对象的相同行为抽象成一个公共接口，对于外部来说就是透明的，例如

```
//文件系统中的节点接口
public interface IFile {
    //下面两个方法，相当于类图中operation方法
    void delete();
    String getName();
    
    /* 以上为公共行为，以下为文件夹才有的行为 */
    
    //创建新文件，相当于add方法
    void createNewFile(String name);
    //相当于remove方法
    void deleteFile(String name);
    //相当于GetChild方法
    IFile getIFile(int index);
}
```

文件系统也可以看作是树形结构，root节点开始，分为文件和文件夹，那么就能抽出相同行为方法。而Folder（文件夹）和File（文件）分别实现自己支持的方法。那么对于客户端来说，就可以使用统一的操作接口去操作文件和文件夹。
但是存在的问题就是：
```
对于组合模式来说，复杂性（安全性）／透明性是不可调和的矛盾。
```

客户端在使用统一接口时，会存在
```
if (movie instanceof Folder) {
            Folder folder = (Folder) movie;
            //下面使用folder进行文件夹独有的操作
        }
```
复杂的逻辑判断，否则可能会出现调用不支持的操作而引起非安全性问题。

### 享元模式
多实例共享，减少内存开销（lol英雄部分属性）
一道经典的面试题
```
Integer.valueOf("1") == Integer.valueOf("1") // true还是false
```
Integer里面有个内部类IntegerCache，用于缓存一些共用的Integer。这个缓存的范围可以在jvm启动的时候进行设置。

