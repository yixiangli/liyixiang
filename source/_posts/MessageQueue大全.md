---
title: MessageQueue大全
toc: true
date: 2016-10-09 10:43:58
category: 
	- 技术贴
	- 中间件
	- MQ系列
	- 总述
tags: 
    - ActiveMQ
    - RabbitMQ
    - ZeroMQ
    - Redis
    - Kafka
---

# what is MessageQueue
什么是消息队列？一种跨进程的通信机制，用于上下游传递消息，是现代互联网企业常用的一种用于服务解耦，异步处理，请求削峰等需求的消息中间件，对于互联网高并发场景的支撑起到了重要的作用

## 场景
使用一项技术的前提就是在了解这项技术的同时，分析这项技术的使用场景，就像设计模式，并不是23种设计模式一起用上，系统就能无比强大，使用不当会造成严重的后果，轻则扩展性差，架构复杂，理解困难，重则难以持续维护，不得不重写，因此，对于深入MQ来说，就需要分析他的使用场景
<!--more-->
### 何时该用
－数据驱动的任务依赖
－上游不关心多下游执行结果
－执行时间长，走异步处理

#### 数据驱动的任务依赖
cron是常见的定时任务，有些时候我们可能有这样的需求:
夜里一点跑 cron A 输入参数 无  执行结果 a
夜里三点跑 cron B 输入参数 a  执行结果 b
夜里五点跑 cron C 输入参数 b  执行结果 全部成功

那么常见的做法就是写三个不同的脚本，分别定时，形成这种依赖关系，第二天上班来看看cron C最终的执行结果。
通常情况下都没有问题，但是如果正巧某一天cron B出了问题，遇到了什么网络抖动，硬件资源不足等等问题，执行了2个半小时才输出结果b，那么可想而知，cron C在夜里五点开始执行肯定是错误的。因此cron定时表的缺点如下：

```
1）如果有一个任务执行时间超过了预留buffer的时间，将会得到错误的结果，因为后置任务不清楚前置任务是否执行成功，此时要手动重跑任务，还有可能要调整定时表
2）总任务的执行时间很长，总是要预留很多buffer，如果前置任务提前完成，后置任务不会提前开始
3）如果一个任务被多个任务依赖，这个任务将会称为关键路径，定时表很难体现依赖关系，容易出错
4）如果有一个任务的执行时间要调整，将会有多个任务的执行时间要调整
```

那我们采用MQ来解耦会怎样呢？
具体方案无非就是上一个任务完成发执行完成消息，通知第二个任务开启，以此类推。优点如下：

```
1）不需要预留buffer，上游任务执行完，下游任务总会在第一时间被执行
2）依赖多个任务，被多个任务依赖都很好处理，只需要订阅相关消息即可
3）有任务执行时间变化，下游任务都不需要调整执行时间
```

#### 上游不关心多下游执行结果
讲道理总得举例子，这种场景我们就拿视频行业媒资系统为例，熟悉业务的人应该知道（不熟悉的可以百度下媒资是什么），媒资系统主要任务就是维护视频专辑等meta信息以及存储介质，并提供给各个视频类app,终端产品。那么媒资系统就是上游，各个视频类app,终端产品就是下游，其实对于媒资系统而言，信息变更，如视频上下线，meta信息变更，都需要告诉下游实时更新，但是无需关心下游如何去更新他们自己的界面展示，信息存储等，只需要告诉他们某某视频有变更，你来查询吧，那么这个时候就可以采用MQ
我们先分析如果不使用MQ会出现哪些问题

```
1）视频更新信息这个操作的整体执行时间会随着下游数量变得非常长
2）下游服务出现问题，可能导致上游系统也出现故障
3）最恶心的一点，新接入了一个下游，上游要修改代码
```

那么如何优化呢，具体方案是，采用MQ解耦：
```
1）视频信息更新成功后，向MQ发一个消息
2）哪个下游关注“视频信息更新”这类消息，主动去MQ订阅
```
如一部火热的电视剧更新了最新集数，TV端，mobile端都需要同步这个信息，那么就可以去订阅这个消息。因此采用MQ的优点是：
```
1）上游执行时间短
2）上下游逻辑+物理解耦，除了与MQ有物理连接，模块之间都不相互依赖
3）新增一个下游消息关注方，上游不需要修改任何代码
```

#### 执行时间长，走异步处理
这个场景肯定也要举个栗子，这个可以拿智能互联项目来说，项目背景我在这篇文章不介绍了哈，其中一个主要功能就是设备信息管理服务，手机/TV等客户端会在开启app的时候上报他们的设备信息，服务端会做相应的逻辑处理，返回客户端一个唯一标识，并将数据入库。当客户端量大或者晚高峰的时候，大量用户同时开启app，服务端压力激增，这个时候就需要异步处理，削峰降流。

具体方案
```
1）请求到达，执行核心逻辑，组织返回状态，返回结果。
2）操作库／公网调用等等操作异步执行。
3）如果异步执行的结果请求方也需要知道，回调之。
```

### 何时不该用
－上游实时关注执行结果

#### 上游实时关注执行结果
纯粹的接口实时调用，需要知道下游的执行结果成功与否，并强依赖这个结果。


## 架构设计

### 消息必达
先申明，个人认为这个命题肯定是个理想命题，至少目前市面上的MQ没有敢吹消息百分百不丢失，不过设计MQ时，消息必达是个必须攻克的难点问题，如何做到呢？主要应该这两个方面：
```
（1）消息落地
（2）消息超时、重传、确认
```

### 幂等性保证
先说说幂等性，幂等性是系统的接口对外一种承诺(而不是实现), 承诺只要调用接口成功, 外部多次调用对系统的影响是一致的. 声明为幂等的接口会认为外部调用失败是常态, 并且失败之后必然会有重试，因此，幂等性其实也就是重复，MQ作为中间过程，势必需要考虑消息重发问题以及重复消息问题的处理，对于重复这个词在开发的角度肯定就自然而然的想到了唯一，那么如何实现幂等性，就取决于如何设置唯一性，保证MQ接收到一条消息后无论出现何种原因都只给下游输出一条消息。

借用比较好的文章分析这个问题
![上半段保证幂等性](/img/mq_idempotency_up.jpg)
![下半段保证幂等性](/img/mq_idempotency_down.jpg)

** 上半段 **
MQ-client生成inner-msg-id，保证上半段幂等。
这个ID全局唯一，业务无关，由MQ保证。
 
** 下半段 **
业务发送方带入biz-id，业务接收方去重保证段等。
这个ID对单业务唯一（如订单ID，设备ID，视频ID），业务相关，对MQ透明。

** 结论 **
幂等性，不仅对MQ有要求，对业务上下游也有要求。

## 几种常见的队列中间件
- jms
- swiftq
- activeMQ
- rabbitmq
- zeromq
- redis
- kafka

## 消息队列常见模型

** 点对点 **
一种p2p模型,发送者与接收者通过Queue进行消息交互
只有一个发送者，一个接收者
无需时间依赖性，接收者不需要提前订阅
发送者不关心接收者是否在线
接收者收到消息，会进行确认ack

** 发布／订阅 **
一种1:n模型，发送者与接收者通过Topic订阅来交互，发布者在某Topic上发布消息，只要订阅了该Topic的接收者都能收到消息
一个发布者，n个订阅者
有时间依赖性，接收者必须提前订阅
接收者必须处于活跃状态以接收消息，除非进行持久化

## 设计模式
观察者模式

### JMS
java自带的消息服务。

#### 基础组件
JMS应用程序由如下基本模块组成：

管理对象（Administered objects）
连接工厂（Connection Factories）
目的地（Destination）
连接对象（Connections）
会话（Sessions）
消息生产者（Message Producers）
消息消费者（Message Consumers）
消息监听者（Message Listeners）

### swiftq
swiftq估计很多人都不认识，这是leEco公司基于QPID0.14版本封装的消息队列中间件集群，与QPID一样，基于AMQP－0-10协议。

#### 几个概念
Broker: 接收和分发消息的应用，一个Server就是Message Broker，如果是swiftq集群，那么一个client可以连接集群中的任意一个Broker，当Broker宕机，可以随时failover到其他Broker上。

Exchange:在AMQP协议模型中，所有生产端发送的message都先经过Exchange服务，该服务主要功能为路由转发，转发主要分为三类

##### Direct
点对点模型，根据routingKey来转发消息，如果message的routingKey与binding一致，则进行转发。

##### Fanout	
广播模型，生产者与消费者往往一对多，上游发送的message，下游的消费者都能接收到，一般用在上游数据更新通知下游各个业务方的场景

##### Topic
发布／订阅模型，根据通配规则，exchange将消息发送至相应的queue中，如"news.#"
通配规则：
“#”通配任何零个或多个word
“*”通配任何单个word
因此，订阅了如news.US | news.CN等订阅者可以收到这条消息。

### ActiveMQ

### RabbitMQ
基于AMQP－0-9-1

### ZeroMQ

### Redis

### Kafka
